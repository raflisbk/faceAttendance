import * as XLSX from 'xlsx'

export interface ExcelReportData {
  reportType: string
  data: {
    users: any[]
    classes: any[]
    attendanceRecords: any[]
    locations: any[]
    faceProfiles: any[]
  }
  dateRange: {
    startDate: Date | null
    endDate: Date | null
  }
  generatedBy: {
    id: string
    name: string
    email: string
    role: string
  }
}

export async function generateExcelReport(reportData: ExcelReportData): Promise<Buffer> {
  const workbook = XLSX.utils.book_new()

  // Generate timestamp for the report
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
  const dateRange = reportData.dateRange.startDate && reportData.dateRange.endDate
    ? `${reportData.dateRange.startDate.toISOString().split('T')[0]} to ${reportData.dateRange.endDate.toISOString().split('T')[0]}`
    : 'All Time'

  // 1. Summary Sheet
  const summaryData = [
    ['Face Attendance System - Admin Report'],
    [''],
    ['Report Type', reportData.reportType],
    ['Generated On', new Date().toLocaleString()],
    ['Generated By', `${reportData.generatedBy.name} (${reportData.generatedBy.email})`],
    ['Date Range', dateRange],
    [''],
    ['Summary Statistics'],
    ['Total Users', reportData.data.users.length],
    ['Total Classes', reportData.data.classes.length],
    ['Total Attendance Records', reportData.data.attendanceRecords.length],
    ['Total Locations', reportData.data.locations.length],
    ['Total Face Profiles', reportData.data.faceProfiles.length],
    [''],
    ['User Breakdown by Role'],
    ['Students', reportData.data.users.filter(u => u.role === 'STUDENT').length],
    ['Lecturers', reportData.data.users.filter(u => u.role === 'LECTURER').length],
    ['Admins', reportData.data.users.filter(u => u.role === 'ADMIN').length],
    [''],
    ['User Status Breakdown'],
    ['Active', reportData.data.users.filter(u => u.status === 'ACTIVE').length],
    ['Pending', reportData.data.users.filter(u => u.status === 'PENDING').length],
    ['Suspended', reportData.data.users.filter(u => u.status === 'SUSPENDED').length],
    ['Rejected', reportData.data.users.filter(u => u.status === 'REJECTED').length]
  ]

  const summarySheet = XLSX.utils.aoa_to_sheet(summaryData)
  XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary')

  // 2. Users Sheet
  const usersData = [
    ['User ID', 'Name', 'Email', 'Role', 'Status', 'Student ID', 'Staff ID', 'Phone', 'Created At', 'Last Login', 'Attendances Count', 'Classes as Lecturer', 'Enrollments Count', 'Face Enrolled']
  ]

  reportData.data.users.forEach(user => {
    usersData.push([
      user.id,
      user.name || '',
      user.email,
      user.role,
      user.status,
      user.studentId || '',
      user.staffId || '',
      user.phone || '',
      user.createdAt ? new Date(user.createdAt).toLocaleString() : '',
      user.lastLogin ? new Date(user.lastLogin).toLocaleString() : '',
      user._count?.attendances || 0,
      user._count?.classesAsLecturer || 0,
      user._count?.enrollments || 0,
      user.faceProfile ? 'Yes' : 'No'
    ])
  })

  const usersSheet = XLSX.utils.aoa_to_sheet(usersData)
  XLSX.utils.book_append_sheet(workbook, usersSheet, 'Users')

  // 3. Classes Sheet
  const classesData = [
    ['Class ID', 'Name', 'Code', 'Description', 'Lecturer Name', 'Lecturer Email', 'Location', 'Building', 'Duration (min)', 'Capacity', 'Is Active', 'Enrollments', 'Total Attendances', 'Created At']
  ]

  reportData.data.classes.forEach(cls => {
    classesData.push([
      cls.id,
      cls.name,
      cls.code,
      cls.description || '',
      cls.lecturer?.name || '',
      cls.lecturer?.email || '',
      cls.location?.name || '',
      cls.location?.building || '',
      cls.duration || '',
      cls.capacity || '',
      cls.isActive ? 'Yes' : 'No',
      cls._count?.enrollments || 0,
      cls._count?.attendances || 0,
      cls.createdAt ? new Date(cls.createdAt).toLocaleString() : ''
    ])
  })

  const classesSheet = XLSX.utils.aoa_to_sheet(classesData)
  XLSX.utils.book_append_sheet(workbook, classesSheet, 'Classes')

  // 4. Attendance Records Sheet
  const attendanceData = [
    ['Attendance ID', 'Student Name', 'Student ID', 'Student Email', 'Class Name', 'Class Code', 'Lecturer Name', 'Date & Time', 'Method', 'Is Valid', 'Confidence Score', 'WiFi SSID', 'IP Address', 'Notes']
  ]

  reportData.data.attendanceRecords.forEach(attendance => {
    attendanceData.push([
      attendance.id,
      attendance.user?.name || '',
      attendance.user?.studentId || '',
      attendance.user?.email || '',
      attendance.class?.name || '',
      attendance.class?.code || '',
      attendance.class?.lecturer?.name || '',
      attendance.timestamp ? new Date(attendance.timestamp).toLocaleString() : '',
      attendance.method || '',
      attendance.isValid ? 'Valid' : 'Invalid',
      attendance.confidenceScore || '',
      attendance.wifiSsid || '',
      attendance.ipAddress || '',
      attendance.notes || ''
    ])
  })

  const attendanceSheet = XLSX.utils.aoa_to_sheet(attendanceData)
  XLSX.utils.book_append_sheet(workbook, attendanceSheet, 'Attendance Records')

  // 5. Locations Sheet
  const locationsData = [
    ['Location ID', 'Name', 'Building', 'Floor', 'Room', 'WiFi SSID', 'Capacity', 'Is Active', 'Classes Count', 'GPS Coordinates']
  ]

  reportData.data.locations.forEach(location => {
    const coordinates = location.gpsCoordinates
      ? `${location.gpsCoordinates.latitude}, ${location.gpsCoordinates.longitude}`
      : ''

    locationsData.push([
      location.id,
      location.name,
      location.building,
      location.floor,
      location.room,
      location.wifiSsid || '',
      location.capacity || '',
      location.isActive ? 'Active' : 'Inactive',
      location._count?.classes || 0,
      coordinates
    ])
  })

  const locationsSheet = XLSX.utils.aoa_to_sheet(locationsData)
  XLSX.utils.book_append_sheet(workbook, locationsSheet, 'Locations')

  // 6. Face Profiles Sheet
  const faceProfilesData = [
    ['Profile ID', 'User Name', 'User Email', 'User Role', 'Quality Score', 'Confidence Threshold', 'Created At', 'Updated At']
  ]

  reportData.data.faceProfiles.forEach(profile => {
    faceProfilesData.push([
      profile.id,
      profile.user?.name || '',
      profile.user?.email || '',
      profile.user?.role || '',
      profile.qualityScore || '',
      profile.confidenceThreshold || '',
      profile.createdAt ? new Date(profile.createdAt).toLocaleString() : '',
      profile.updatedAt ? new Date(profile.updatedAt).toLocaleString() : ''
    ])
  })

  const faceProfilesSheet = XLSX.utils.aoa_to_sheet(faceProfilesData)
  XLSX.utils.book_append_sheet(workbook, faceProfilesSheet, 'Face Profiles')

  // Apply formatting to all sheets
  const sheetNames = workbook.SheetNames
  sheetNames.forEach(sheetName => {
    const sheet = workbook.Sheets[sheetName]

    // Auto-fit columns
    const range = XLSX.utils.decode_range(sheet['!ref'] || 'A1:A1')
    const colWidths: { wch: number }[] = []

    for (let col = range.s.c; col <= range.e.c; col++) {
      let maxWidth = 10
      for (let row = range.s.r; row <= range.e.r; row++) {
        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col })
        const cell = sheet[cellAddress]
        if (cell && cell.v) {
          const cellLength = cell.v.toString().length
          maxWidth = Math.max(maxWidth, Math.min(cellLength, 50))
        }
      }
      colWidths.push({ wch: maxWidth })
    }

    sheet['!cols'] = colWidths

    // Style header row (if it's not the summary sheet)
    if (sheetName !== 'Summary') {
      for (let col = range.s.c; col <= range.e.c; col++) {
        const headerCell = XLSX.utils.encode_cell({ r: 0, c: col })
        if (!sheet[headerCell]) sheet[headerCell] = { t: 's', v: '' }
        sheet[headerCell].s = {
          font: { bold: true },
          fill: { fgColor: { rgb: 'E6E6E6' } },
          alignment: { horizontal: 'center' }
        }
      }
    }
  })

  // Generate buffer
  const buffer = XLSX.write(workbook, {
    type: 'buffer',
    bookType: 'xlsx',
    compression: true
  })

  return buffer
}

// Helper function to create attendance summary report
export async function generateAttendanceSummaryReport(
  attendanceData: any[],
  dateRange: { startDate: Date | null; endDate: Date | null },
  generatedBy: any
): Promise<Buffer> {
  const workbook = XLSX.utils.book_new()

  // Attendance Summary
  const summaryData = [
    ['Attendance Summary Report'],
    [''],
    ['Generated On', new Date().toLocaleString()],
    ['Generated By', `${generatedBy.name} (${generatedBy.email})`],
    ['Date Range', dateRange.startDate && dateRange.endDate
      ? `${dateRange.startDate.toISOString().split('T')[0]} to ${dateRange.endDate.toISOString().split('T')[0]}`
      : 'All Time'],
    [''],
    ['Statistics'],
    ['Total Records', attendanceData.length],
    ['Valid Attendances', attendanceData.filter(a => a.isValid).length],
    ['Invalid Attendances', attendanceData.filter(a => !a.isValid).length],
    ['Face Recognition', attendanceData.filter(a => a.method === 'FACE_RECOGNITION').length],
    ['QR Code', attendanceData.filter(a => a.method === 'QR_CODE').length],
    ['Manual', attendanceData.filter(a => a.method === 'MANUAL').length]
  ]

  const summarySheet = XLSX.utils.aoa_to_sheet(summaryData)
  XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary')

  // Detailed Records
  const detailsData = [
    ['Date', 'Student', 'Class', 'Method', 'Status', 'Confidence', 'Time', 'Location Info']
  ]

  attendanceData.forEach(record => {
    detailsData.push([
      record.timestamp ? new Date(record.timestamp).toLocaleDateString() : '',
      record.user?.name || '',
      record.class?.name || '',
      record.method || '',
      record.isValid ? 'Valid' : 'Invalid',
      record.confidenceScore || '',
      record.timestamp ? new Date(record.timestamp).toLocaleTimeString() : '',
      record.wifiSsid || record.ipAddress || ''
    ])
  })

  const detailsSheet = XLSX.utils.aoa_to_sheet(detailsData)
  XLSX.utils.book_append_sheet(workbook, detailsSheet, 'Detailed Records')

  const buffer = XLSX.write(workbook, {
    type: 'buffer',
    bookType: 'xlsx',
    compression: true
  })

  return buffer
}

// Helper function to create user report
export async function generateUserReport(
  userData: any[],
  generatedBy: any
): Promise<Buffer> {
  const workbook = XLSX.utils.book_new()

  // User Summary
  const summaryData = [
    ['User Management Report'],
    [''],
    ['Generated On', new Date().toLocaleString()],
    ['Generated By', `${generatedBy.name} (${generatedBy.email})`],
    [''],
    ['User Statistics'],
    ['Total Users', userData.length],
    ['Students', userData.filter(u => u.role === 'STUDENT').length],
    ['Lecturers', userData.filter(u => u.role === 'LECTURER').length],
    ['Admins', userData.filter(u => u.role === 'ADMIN').length],
    ['Active Users', userData.filter(u => u.status === 'ACTIVE').length],
    ['Pending Users', userData.filter(u => u.status === 'PENDING').length],
    ['Face Enrolled Users', userData.filter(u => u.faceProfile).length]
  ]

  const summarySheet = XLSX.utils.aoa_to_sheet(summaryData)
  XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary')

  // User Details
  const usersData = [
    ['Name', 'Email', 'Role', 'Status', 'Student/Staff ID', 'Phone', 'Face Enrolled', 'Created Date', 'Last Login']
  ]

  userData.forEach(user => {
    usersData.push([
      user.name || '',
      user.email,
      user.role,
      user.status,
      user.studentId || user.staffId || '',
      user.phone || '',
      user.faceProfile ? 'Yes' : 'No',
      user.createdAt ? new Date(user.createdAt).toLocaleDateString() : '',
      user.lastLogin ? new Date(user.lastLogin).toLocaleDateString() : 'Never'
    ])
  })

  const usersSheet = XLSX.utils.aoa_to_sheet(usersData)
  XLSX.utils.book_append_sheet(workbook, usersSheet, 'User Details')

  const buffer = XLSX.write(workbook, {
    type: 'buffer',
    bookType: 'xlsx',
    compression: true
  })

  return buffer
}